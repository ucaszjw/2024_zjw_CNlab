% -----------------------------*- LaTeX -*------------------------------
\documentclass[UTF8]{report}
% ------------------------------------------------------------------------
% Packages
% ------------------------------------------------------------------------
\usepackage{ctex} % 支持中文
\usepackage[body={7in, 9in},left=1in,right=1in]{geometry} % 改变页边距
\usepackage{amsmath} % AMS 的数学宏包
\usepackage{amsfonts} % AMS 的数学字体宏包
\usepackage{amssymb} % AMS 符号库
\usepackage{bm} % 数学公式中的黑斜体
\usepackage{amsthm} % AMS 的定理环境宏包
\usepackage{graphicx} % 插图
\usepackage{subfigure} % 插子图
\usepackage{nicefrac} % 好看的分数
\usepackage{mathrsfs} % mathscr font
\usepackage{caption} % caption
\usepackage{algorithm,algorithmicx} % 伪代码支持宏包
\usepackage[noend]{algpseudocode} % 伪代码
\usepackage{fancyhdr} % 设置页眉、页脚
\usepackage{adjustbox} % 图片尺寸自动调整
\usepackage{esint} % 积分符号
\usepackage{mathtools} % 数学宏包的重要补充
\usepackage{upgreek} % 数学环境的直立希腊字母
\usepackage{enumitem} % 使用enumitem宏包, 改变列表项的格式
\usepackage{color} % 支持彩色
\usepackage{extarrows} % 任意长度的箭头
\usepackage{tikz} % 绘图
\usepackage{forest} % 绘树
\usepackage{xcolor} % 颜色宏包
\usepackage{breqn} % 公式自动换行
\usepackage{fontsize} % 字体大小
\usepackage[framemethod=TikZ]{mdframed} % 给文字加框
\usepackage{fontspec} % 字体库
\usepackage{bigstrut} % 用于表格中的换行
\usepackage{multirow} % 表格中多行单元格合并
\usepackage{multicol} % 表格中多列单元格合并
\usepackage{longtable} % 长表格
\usepackage{rotating} % 旋转图形和表格      以上三者用于绘制三线表
\usepackage{booktabs} % 三线表宏包
\usepackage{scribe} % Scribe 模板
\usepackage{diagbox} % 表格斜线
\usepackage{listings} % 插入代码
\usepackage{verbatim} % 多行注释
\usepackage{ifplatform} % 检测编译平台
\usepackage{pifont} % 圆圈数字
\usetikzlibrary{shapes.geometric, arrows} % 引入流程图需要的库
\usetikzlibrary{automata} % 引入automata库
\usetikzlibrary{shapes,arrows,positioning,chains} % 引入positioning库
% ------------------------------------------------------------------------
% Macros
% ------------------------------------------------------------------------
%~~~~~~~~~~~~~~~
% Utility latin
%~~~~~~~~~~~~~~~
\newcommand{\ie}{\textit{i.e.}}
\newcommand{\eg}{\textit{e.g.}}
%~~~~~~~~~~~~~~~
% Environment shortcuts
%~~~~~~~~~~~~~~~
\newcommand{\balign}[1]{\ealign{\begin{align}#1\end{align}}}
\newcommand{\baligns}[1]{\ealigns{\begin{align*}#1\end{align*}}}
\newcommand{\bitemize}[1]{\eitemize{\begin{itemize}#1\end{itemize}}}
\newcommand{\benumerate}[1]{\eenumerate{\begin{enumerate}#1\end{enumerate}}}
%~~~~~~~~~~~~~~~
% Text with quads around it
%~~~~~~~~~~~~~~~
\newcommand{\qtext}[1]{\quad\text{#1}\quad}
%~~~~~~~~~~~~~~~
% Shorthand for math formatting
%~~~~~~~~~~~~~~~
\newcommand{\mbb}[1]{\mathbb{#1}}
\newcommand{\mbi}[1]{\boldsymbol{#1}} % Bold and italic (math bold italic)
\newcommand{\mbf}[1]{\mathbf{#1}}
\newcommand{\mc}[1]{\mathcal{#1}}
\newcommand{\mrm}[1]{\mathrm{#1}}
\newcommand{\tbf}[1]{\textbf{#1}}
\newcommand{\tsc}[1]{\textsc{#1}}
%\def\\langle {{\langle }}
%\def\\rangle {{\rangle }}
\newcommand{\sT}{\sf T}
\newcommand{\grad}{\nabla}
\newcommand{\Proj}{\Pi}
%~~~~~~~~~~~~~~~
% Common sets 定义数集符号
%~~~~~~~~~~~~~~~
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\reals}{\mathbb{R}} % Real number symbol
\newcommand{\integers}{\mathbb{Z}} % Integer symbol
\newcommand{\rationals}{\mathbb{Q}} % Rational numbers
\newcommand{\naturals}{\mathbb{N}} % Natural numbers
\newcommand{\complex}{\mathbb{C}} % Complex numbers
%~~~~~~~~~~~~~~~
% Common functions
%~~~~~~~~~~~~~~~
\renewcommand{\exp}[1]{\operatorname{exp}\left(#1\right)} % Exponential
\newcommand{\indic}[1]{\mbb{I}\left(#1\right)} % Indicator function
\newcommand{\indicsub}[2]{\mbb{I}_{#2}\left(#1\right)} % Indicator function
\newcommand{\argmax}{\mathop\mathrm{arg\, max}} % Defining math symbols
\newcommand{\argmin}{\mathop\mathrm{arg\, min}}
\renewcommand{\arccos}{\mathop\mathrm{arccos}}
\newcommand{\dom}{\mathop\mathrm{dom}} % Domain
\newcommand{\range}{\mathop\mathrm{range}} % Range
\newcommand{\diag}{\mathop\mathrm{diag}}
\newcommand{\tr}{\mathop\mathrm{tr}}
\newcommand{\abs}{\mathop\mathrm{abs}}
\newcommand{\card}{\mathop\mathrm{card}}
\newcommand{\sign}{\mathop\mathrm{sign}}
\newcommand{\prox}{\mathrm{prox}} % prox
\newcommand{\rank}[1]{\mathrm{rank}(#1)}
\newcommand{\supp}[1]{\mathrm{supp}(#1)}
\newcommand{\norm}[1]{\lVert#1\rVert}
%~~~~~~~~~~~~~~~
% Common probability symbols
%~~~~~~~~~~~~~~~
\newcommand{\family}{\mathcal{P}} % probability family / statistical model
\newcommand{\iid}{\stackrel{\mathrm{iid}}{\sim}}
\newcommand{\ind}{\stackrel{\mathrm{ind}}{\sim}}
\newcommand{\E}{\mathbb{E}} % Expectation symbol
\newcommand{\Earg}[1]{\E\left[#1\right]}
\newcommand{\Esubarg}[2]{\E_{#1}\left[#2\right]}
\renewcommand{\P}{\mathbb{P}} % Probability symbol
\newcommand{\Parg}[1]{\P\left(#1\right)}
\newcommand{\Psubarg}[2]{\P_{#1}\left[#2\right]}
%\newcommand{\Cov}{\mrm{Cov}} % Covariance symbol
%\newcommand{\Covarg}[1]{\Cov\left[#1\right]}
%\newcommand{\Covsubarg}[2]{\Cov_{#1}\left[#2\right]}
%\newcommand{\model}{\mathcal{P}} % probability family / statistical model
%~~~~~~~~~~~~~~~
% Distributions
%~~~~~~~~~~~~~~~
%\newcommand{\Gsn}{\mathcal{N}}
%\newcommand{\Ber}{\textnormal{Ber}}
%\newcommand{\Bin}{\textnormal{Bin}}
%\newcommand{\Unif}{\textnormal{Unif}}
%\newcommand{\Mult}{\textnormal{Mult}}
%\newcommand{\NegMult}{\textnormal{NegMult}}
%\newcommand{\Dir}{\textnormal{Dir}}
%\newcommand{\Bet}{\textnormal{Beta}}
%\newcommand{\Gam}{\textnormal{Gamma}}
%\newcommand{\Poi}{\textnormal{Poi}}
%\newcommand{\HypGeo}{\textnormal{HypGeo}}
%\newcommand{\GEM}{\textnormal{GEM}}
%\newcommand{\BP}{\textnormal{BP}}
%\newcommand{\DP}{\textnormal{DP}}
%\newcommand{\BeP}{\textnormal{BeP}}
%\newcommand{\Exp}{\textnormal{Exp}}
%~~~~~~~~~~~~~~~
% Theorem-like environments
%~~~~~~~~~~~~~~~
%\theoremstyle{definition}
%\newtheorem{definition}{Definition}
%\newtheorem{example}{Example}
%\newtheorem{problem}{Problem}
%\newtheorem{lemma}{Lemma}
%~~~~~~~~~~~~~~~
% 组合数学的模板和作业里用到的一些宏包和自定义命令
%~~~~~~~~~~~~~~~
\renewcommand{\emph}[1]{\begin{kaishu}#1\end{kaishu}}
\newcommand{\falfac}[1]{^{\underline{#1}}}
\newcommand{\binomfrac}[2]{\frac{#1^{\underline{#2}}}{#2!}}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\suminfty}[2]{\sum_{#1=#2}^{\infty}}
\newcommand{\suminftyk}[0]{\sum_{k=0}^{\infty}}
\newcommand{\sumint}[3]{\sum_{#1=#2}^{#3}}
\newcommand{\sumintk}[2]{\sum_{k=#1}^{#2}}
\newcommand{\suminti}[2]{\sum_{i=#1}^{#2}}
%~~~~~~~~~~~~~~~
% 定义新命令
%~~~~~~~~~~~~~~~
\newcommand*{\unit}[1]{\mathop{}\!\mathrm{#1}}
\newcommand*{\dif}{\mathop{}\!\mathrm{d}}%微分算子 d
\newcommand*{\pdif}{\mathop{}\!\partial}%偏微分算子
\newcommand*{\cdif}{\mathop{}\!\nabla}%协变导数、nabla 算子
\newcommand*{\laplace}{\mathop{}\!\Delta}%laplace 算子
\newcommand*{\deri}[1]{\mathrm{d} #1}
\newcommand*{\deriv}[2]{\frac{\mathrm{d} #1}{\mathrm{d} {#2}}}
\newcommand*{\derivh}[3]{\frac{\mathrm{d}^{#1} #2}{\mathrm{d} {#3^{#1}}}}
\newcommand*{\pderiv}[2]{\frac{\partial #1}{\partial {#2}}}
\newcommand*{\pderivh}[3]{\frac{\partial^{#1} #2}{\partial {#3^{#1}}}}
\newcommand*{\dderiv}[2]{\dfrac{\mathrm{d} #1}{\mathrm{d} {#2}}}
\newcommand*{\dderivh}[3]{\dfrac{\mathrm{d}^{#1} #2}{\mathrm{d} {#3^{#1}}}}
\newcommand*{\dpderiv}[2]{\dfrac{\partial #1}{\partial {#2}}}
\newcommand*{\dpderivh}[3]{\dfrac{\partial^{#1} #2}{\partial {#3^{#1}}}}
\newcommand{\me}[1]{\mathrm{e}^{#1}}%e 指数
\newcommand{\mi}{\mathrm{i}}%虚数单位
%\newcommand{\mc}{\mathrm{c}}%光速 定义与mathcal冲突
\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcommand{\blue}[1]{\textcolor{blue}{#1}}
%\newcommand{\Rome}[1]{\setcounter{rome}{#1}\Roman{rome}}
%~~~~~~~~~~~~~~~
% 公式环境中箭头符号的简写
%~~~~~~~~~~~~~~~
\newcommand{\ra}{\rightarrow}
\newcommand{\Ra}{\Rightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\La}{\Leftarrow}
\newcommand{\lra}{\leftrightarrow}
\newcommand{\Lra}{\Leftrightarrow}
\newcommand{\lgla}{\longleftarrow}
\newcommand{\Lgla}{\Longleftarrow}
\newcommand{\lgra}{\longrightarrow}
\newcommand{\Lgra}{\Longrightarrow}
\newcommand{\lglra}{\longleftrightarrow}
\newcommand{\Lglra}{\Longleftrightarrow}
%~~~~~~~~~~~~~~~
% 一些数学的环境设置
%~~~~~~~~~~~~~~~
%\newcounter{counter_exm}\setcounter{counter_exm}{1}
%\newcounter{counter_prb}\setcounter{counter_prb}{1}
%\newcounter{counter_thm}\setcounter{counter_thm}{1}
%\newcounter{counter_lma}\setcounter{counter_lma}{1}
%\newcounter{counter_dft}\setcounter{counter_dft}{1}
%\newcounter{counter_clm}\setcounter{counter_clm}{1}
%\newcounter{counter_cly}\setcounter{counter_cly}{1}
\newtheorem{theorem}{{\hskip 1.7em \bf 定理}}
\newtheorem{lemma}[theorem]{\hskip 1.7em 引理}
\newtheorem{proposition}[theorem]{\hskip 1.7em 命题}
\newtheorem{claim}[theorem]{\hskip 1.7em 断言}
\newtheorem{corollary}[theorem]{\hskip 1.7em 推论}
% \newcommand{\problem}[1]{{\setlength{\parskip}{10pt}\noindent \bf{#1}}}
\newenvironment{solution}{{\noindent \bf 解 \quad}}{}
\newenvironment{remark}{{\noindent \bf 注 \quad}}{}
\newenvironment{definition}{{\noindent \bf 定义 \quad}}{}
\renewenvironment{proof}{{\setlength{\parskip}{7pt}\noindent\hskip 2em \bf 证明 \quad}}{\hfill$\qed$\par}
\newenvironment{example}{{\noindent\bf 例 \quad}}{\hfill$\qed$\par}
%\newenvironment{concept}[1]{{\bf #1\quad} \begin{kaishu}} {\end{kaishu}\par}
%~~~~~~~~~~~~~~~
% 本.tex文档中特殊定义命令
%~~~~~~~~~~~~~~~
\newcommand{\lno}[1]{\overline{#1}}
\newcommand{\NP}{\mathrm{NP}}
\newcommand{\coNP}{\mathrm{coNP}}
% \newcommand{\ISO}{\mathrm{ISO}}
\newcommand{\SAT}{\mathrm{SAT}}
\newcommand{\USAT}{\mathrm{USAT}}
% \newcommand{\threeSAT}{\mathrm{3\text{-}SAT}}
\renewcommand{\P}{\mathrm{P}}
% \mathchardef\mhyphen="2D
% \newcommand{\CNF}{\mathrm{CNF}}
% \newcommand{\DNF}{\mathrm{DNF}}
% \newcommand{\SetSp}{\mathrm{SET\text{-}SPLITTING}}
% \newcommand{\PUZZLE}{\mathrm{PUZZLE}}
% \newcommand{\SPATH}{\mathrm{SPATH}}
% \newcommand{\LPATH}{\mathrm{LPATH}}
% \newcommand{\UHAMPATH}{\mathrm{UHAMPATH}}
\newcommand{\SPACE}{\mathrm{SPACE}}
\newcommand{\NSPACE}{\mathrm{NSPACE}}
\newcommand{\PSPACE}{\mathrm{PSPACE}}
\newcommand{\NPSPACE}{\mathrm{NPSPACE}}
\newcommand{\DFA}{\mathrm{DFA}}
\newcommand{\NFA}{\mathrm{NFA}}
\newcommand{\TQBF}{\mathrm{TQBF}}
% \newcommand{\L}{\mathrm{L}}
\renewcommand{\O}{\mathrm{O}}
\newcommand{\NL}{\mathrm{NL}}
\newcommand{\coNL}{\mathrm{coNL}}
\newcommand{\LADDER}{\mathrm{LADDER_{DFA}}}
\newcommand{\hd}{\mathrm{\text{-}hard}}
\newcommand{\ADD}{\mathrm{ADD}}
\newcommand{\STCN}{\mathrm{STRONGLY\text{-}CONNECTED}}
\newcommand{\PATH}{\mathrm{PATH}}
\newcommand{\A}{\mathrm{A}}
%使用align环境公式换页
\allowdisplaybreaks[4]

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{
  frame=tb,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  framerule=1pt,
  rulecolor=\color{gray!35},
  backgroundcolor=\color{gray!5},
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}

\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=red!30]
\tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=orange!30]
\tikzstyle{decision} = [diamond, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=green!30]
\tikzstyle{arrow} = [thick,->,>=stealth]

\ifwindows
    \setmainfont{Times New Roman}
    \setsansfont{Times New Roman}
    \setmonofont{Consolas}
    \setCJKmainfont{SimHei}
    \setCJKsansfont{SimSun}
    \setCJKmonofont{FangSong}
\fi

\ifmacosx
    \setmainfont{Times New Roman}
    \setsansfont{Times New Roman}
    \setmonofont{Menlo}
    \setCJKmainfont{STHeiti}
    \setCJKsansfont{STSong}
    \setCJKmonofont{STFangsong}
\fi

\punctstyle{kaiming}

\begin{document}

\pagestyle{fancy}

\reporttype{Report}                 % required
\course{Lab of Computer Network} 				% optional
\coursetitle{stp}	    % optional
\semester{Fall 2024}			    % optional
\lecturer{Wu Qinghua}			% optional
\scribe{Zhang Jiawei}			% required
\lecturenumber{5}				% required (must be a number)
\lecturedate{September 29}			% required (omit year)
\maketitle

\section{实验内容}

\begin{enumerate}
  \item 基于已有代码，实现生成树运行机制，对于给定拓扑(four_node_ring.py)，计算输出相应状态下的最小生成树拓扑。
  \item 自己构造一个不少于7个节点，冗余链路不少于2条的拓扑，节点和端口的命名规则可参考four_node_ring.py，使用stp程序计算输出最小生成树拓扑。
\end{enumerate}

\section{实验过程}

\subsection{总体流程}

本次实验中，计算最小生成树拓扑需要实现的操作比较多，用流程图概括如下：

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\textwidth]{total.png}
  \caption{总体流程}
\end{figure}

网段中的两个节点，通过收发config消息，并比较自身收端口config和对端发端口config的优先级，来决定自己的状态。如果收到的config优先级高，说明该网段应该通过对方端口连接根节点，需要进行以下操作：

\begin{enumerate}
  \item 将本端口的config替换为收到的config消息(\ding{174}) ，本端口为非指定端口；
  \item 更新节点状态(\ding{175})；
  \item 更新其余(Other)端口的config(\ding{176})；
  \item 如果节点由根节点变为非根节点，停止hello定时器；
  \item 将更新后的config从每个指定端口转发出去(\ding{172})。
\end{enumerate}

如果收到的config优先级低，则该网段应该通过本端口存储config对应的端口连接根节点，只需要发送config消息(\ding{172})告知对方优先级更高的config。

\subsection{比较config优先级}

比较config优先级的操作如下图所示：

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\textwidth]{compare.png}
  \caption{比较config优先级}
\end{figure}

转化为C代码如下：

\begin{lstlisting}[language=C]
  // return true if config of p is superior to the received config
  static bool config_is_superior(stp_port_t *p, u64 designated_root, u32 root_path_cost, u64 switch_id, u16 port_id)
  {
    if (p->designated_root < designated_root)
      return true;
    else if (p->designated_root > designated_root)
      return false;
    else if (p->designated_cost < root_path_cost)
      return true;
    else if (p->designated_cost > root_path_cost)
      return false;
    else if (p->designated_switch < switch_id)
      return true;
    else if (p->designated_switch > switch_id)
      return false;
    else if (p->designated_port < port_id)
      return true;
    else
      return false;
  }
\end{lstlisting}

这里的\texttt{stp_port_t *p}表示自身收端口，按照上图所示方法进行比较，如果自己的优先级更高，就返回\texttt{true}，否则返回\texttt{false}。

优先级比较完之后，需要根据结果进行相应的操作。如果自己的优先级更高，就从指定端口发出config消息：

\begin{lstlisting}[language=C]
	u64 designated_root = ntohll(config->root_id);
	u32 root_path_cost = ntohl(config->root_path_cost);
	u64 switch_id = ntohll(config->switch_id);
	u16 port_id = ntohs(config->port_id);
	//  if config of p is superior and p is designated, just send config
	if (config_is_superior(p, designated_root, root_path_cost, switch_id, port_id) && stp_port_is_designated(p))
			stp_port_send_config(p);
\end{lstlisting}

如果自己的优先级更低，所需的操作较多，在后面一一叙述。

\subsection{更新本端口config}

这一部分比较简单，只需要将本端口的config的各个域更新为收到的config的各个域即可：

\begin{lstlisting}[language=C]
  // 1. replace config of p with config of entry
  p->designated_root = designated_root;
  p->designated_switch = switch_id;
  p->designated_port = port_id;
  p->designated_cost = root_path_cost;
\end{lstlisting}

\subsection{更新节点状态}

首先遍历所有端口，满足如下条件的为根端口(root\_port)：

\begin{enumerate}
  \item 该端口是非指定端口；
  \item 该端口的优先级要高于所有其余非指定端口(\ding{173})；
\end{enumerate}

我先写了一个函数来寻找根端口：

\begin{lstlisting}[language=C]
  // locate root port: the most superior non-designated port
  static stp_port_t *locate_root_port(stp_t *stp)
  {
    stp_port_t *root_port = NULL;
    stp_port_t *current_port;
  
    for (int i = 0; i < stp->nports; i++){
      current_port = &stp->ports[i];
      if (!stp_port_is_designated(current_port)){
        if(root_port){
          if(config_is_superior(current_port, root_port->designated_root, root_port->designated_cost, root_port->designated_switch, root_port->port_id))
            root_port = current_port;
        }
        else
          root_port = current_port;
      }
    }
        
    return root_port;
  }
\end{lstlisting}

然后更新节点状态，选择通过root\_port连接到根节点：

\begin{lstlisting}[language=C]
  // 2. upgrade stp state
  stp_port_t *root_port = locate_root_port(stp);

  if (root_port){
    stp->root_port = root_port;
    stp->designated_root = root_port->designated_root;
    stp->root_path_cost = root_port->designated_cost + root_port->path_cost;
  }
  else{
    stp->root_port = NULL;
    stp->designated_root = stp->switch_id;
    stp->root_path_cost = 0;
  }
\end{lstlisting}

这里\texttt{stp->root_path_cost}的更新是因为路径开销等于路径上全部链路开销之和。

\subsection{更新其余端口config}

更新其余端口的config有多种情况：

\begin{enumerate}
  \item 非指定端口 $\rightarrow$ 非指定端口（不需要处理）；
  \item 指定端口 $\rightarrow$ 指定端口（需要更新信息，对于所有指定端口，更新其认为的根节点和路径开销）；
  \item 指定端口 $\rightarrow$ 非指定端口（只有收到config时可能，已在之前的函数中处理）；
  \item 非指定端口 $\rightarrow$ 指定端口（如果一个端口为非指定端口，且其Config较网段内其他端口优先级更高(\ding{173})，那么该端口成为指定端口）。
\end{enumerate}

代码如下：

\begin{lstlisting}[language=C]
  // 3. upgrade config of other ports
  // for non-designated ports, if it's superior to all other ports, set it as designated
  for (int i = 0; i < stp->nports; i++){
    stp_port_t* current_port = &stp->ports[i];
    if (root_port && !stp_port_is_designated(current_port) && !config_is_superior(current_port, stp->designated_root, stp->root_path_cost, stp->switch_id, current_port->port_id)){
          current_port->designated_switch = stp->switch_id;
          current_port->designated_port = current_port->port_id;
    }
  }

  // for all designated ports, update designated root and cost
  for (int i = 0; i < stp->nports; i++){
    stp_port_t* current_port = &stp->ports[i];
    if (stp_port_is_designated(current_port)){
      current_port->designated_root = stp->designated_root;
      current_port->designated_cost = stp->root_path_cost;
    }
  }
\end{lstlisting}

\subsection{停止hello定时器}

如果节点由根节点变为非根节点，需要停止hello定时器：

\begin{lstlisting}[language=C]
  // get before_root before receiving config
  int before_root = stp_is_root_switch(stp);

  // 4. if root port is changed, stop hello timer
  if (before_root && !stp_is_root_switch(stp))
    stp_stop_timer(&stp->hello_timer);
\end{lstlisting}

\subsection{转发config}

最后，将更新后的config从每个指定端口转发出去：

\begin{lstlisting}[language=C]
  // 5. send config from all designated ports
  stp_send_config(stp);
\end{lstlisting}

\section{实验结果}

\subsection{使用four\_node\_ring.py}

使用four\_node\_ring.py拓扑，运行stp程序，可以得到如下结果：

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\textwidth]{four_node_ring.png}
  \caption{four\_node\_ring.py拓扑}
\end{figure}

四节点环路拓扑如下：

\begin{lstlisting}[language=Python]
  class RingTopo(Topo):
  def build(self):
      b1 = self.addHost('b1')
      b2 = self.addHost('b2')
      b3 = self.addHost('b3')
      b4 = self.addHost('b4')

      self.addLink(b1, b2)
      self.addLink(b1, b3)
      self.addLink(b2, b4)
      self.addLink(b3, b4)
\end{lstlisting}

\begin{figure}[H]
  \centering
  \subfigure[拓扑图]{
    \includegraphics[width=0.4\textwidth]{four_node_ring_topo.png}
  }
  \subfigure[stp结果]{
    \includegraphics[width=0.4\textwidth]{four_node_ring_result.png}
  }
  \caption{four\_node\_ring.py拓扑}
\end{figure}

\subsection{自定义拓扑}

我自定义了一个七节点完全图拓扑seven_node_complete.py，运行stp程序，可以得到如下结果：

\begin{figure}[H]
  \centering
  \subfigure{
    \includegraphics[width=0.7\textwidth]{seven_node_complete_1.png}
  }
  \subfigure{
    \includegraphics[width=0.7\textwidth]{seven_node_complete_2.png}
  }
\end{figure}

\begin{figure}[H]
  \centering
  \subfigure{
    \includegraphics[width=0.7\textwidth]{seven_node_complete_3.png}
  }
  \hspace{0pt}
  \subfigure{
    \includegraphics[width=0.7\textwidth]{seven_node_complete_4.png}
  }
  \caption{七节点完全图拓扑}  
\end{figure}

七节点完全图拓扑如下：

\begin{lstlisting}[language=Python]
  class CompleteTopo(Topo):
  def build(self):
      b1 = self.addHost('b1')
      b2 = self.addHost('b2')
      b3 = self.addHost('b3')
      b4 = self.addHost('b4')
      b5 = self.addHost('b5')
      b6 = self.addHost('b6')
      b7 = self.addHost('b7')

      self.addLink(b1, b2)
      self.addLink(b1, b3)
      self.addLink(b1, b4)
      self.addLink(b1, b5)
      self.addLink(b1, b6)
      self.addLink(b1, b7)
      # code omitted
      self.addLink(b5, b6)
      self.addLink(b5, b7)
      self.addLink(b6, b7)
\end{lstlisting}

\begin{figure}[H]
  \centering
  \subfigure[七节点完全图拓扑]{  
    \begin{tikzpicture}
      \foreach \i in {1,...,7} {
        \node[draw, circle] (b\i) at ({360/7 * (\i - 1) + 90}:2) {b\i};
      }
      \foreach \i in {1,...,7} {
        \foreach \j in {\i,...,7} {
          \ifnum\i<\j
            \draw (b\i) -- (b\j);
          \fi
        }
      }
    \end{tikzpicture}
  }
  \subfigure[stp结果]{
    \begin{tikzpicture}
      \foreach \i in {1,...,7} {
        \node[draw, circle] (b\i) at ({360/7 * (\i - 1) + 90}:2) {b\i};
      }
      \foreach \i in {2,...,7} {
        \draw (b\i) -- (b1);
      }
    \end{tikzpicture}
  }
  \caption{七节点完全图拓扑}
\end{figure}

可以看出算法正确地计算出了最小生成树拓扑。

\section{实验总结}

本次实验实现了生成树运行机制，对于给定拓扑，计算输出相应状态下的最小生成树拓扑。实验中，我实现了比较config优先级、更新本端口config、更新节点状态、更新其余端口config、停止hello定时器、转发config等操作，最终使用four\_node\_ring.py和自定义的七节点完全图拓扑进行了测试，得到了正确的结果。这让我更加深入地理解了生成树算法的运行机制。

\end{document}