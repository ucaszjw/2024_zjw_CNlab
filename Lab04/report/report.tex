% -----------------------------*- LaTeX -*------------------------------
\documentclass[UTF8]{report}
% ------------------------------------------------------------------------
% Packages
% ------------------------------------------------------------------------
\usepackage{ctex} % 支持中文
\usepackage[body={7in, 9in},left=1in,right=1in]{geometry} % 改变页边距
\usepackage{amsmath} % AMS 的数学宏包
\usepackage{amsfonts} % AMS 的数学字体宏包
\usepackage{amssymb} % AMS 符号库
\usepackage{bm} % 数学公式中的黑斜体
\usepackage{amsthm} % AMS 的定理环境宏包
\usepackage{graphicx} % 插图
\usepackage{subfigure} % 插子图
\usepackage{nicefrac} % 好看的分数
\usepackage{mathrsfs} % mathscr font
\usepackage{caption} % caption
\usepackage{algorithm,algorithmicx} % 伪代码支持宏包
\usepackage[noend]{algpseudocode} % 伪代码
\usepackage{fancyhdr} % 设置页眉、页脚
\usepackage{adjustbox} % 图片尺寸自动调整
\usepackage{esint} % 积分符号
\usepackage{mathtools} % 数学宏包的重要补充
\usepackage{upgreek} % 数学环境的直立希腊字母
\usepackage{enumitem} % 使用enumitem宏包, 改变列表项的格式
\usepackage{color} % 支持彩色
\usepackage{extarrows} % 任意长度的箭头
\usepackage{tikz} % 绘图
\usepackage{forest} % 绘树
\usepackage{xcolor} % 颜色宏包
\usepackage{breqn} % 公式自动换行
\usepackage{fontsize} % 字体大小
\usepackage[framemethod=TikZ]{mdframed} % 给文字加框
\usepackage{fontspec} % 字体库
\usepackage{bigstrut} % 用于表格中的换行
\usepackage{multirow} % 表格中多行单元格合并
\usepackage{multicol} % 表格中多列单元格合并
\usepackage{longtable} % 长表格
\usepackage{rotating} % 旋转图形和表格      以上三者用于绘制三线表
\usepackage{booktabs} % 三线表宏包
\usepackage{scribe} % Scribe 模板
\usepackage{diagbox} % 表格斜线
\usepackage{listings} % 插入代码
\usepackage{verbatim} % 多行注释
\usetikzlibrary{shapes.geometric, arrows} % 引入流程图需要的库
\usetikzlibrary{automata} % 引入automata库
\usetikzlibrary{shapes,arrows,positioning,chains} % 引入positioning库
% ------------------------------------------------------------------------
% Macros
% ------------------------------------------------------------------------
%~~~~~~~~~~~~~~~
% Utility latin
%~~~~~~~~~~~~~~~
\newcommand{\ie}{\textit{i.e.}}
\newcommand{\eg}{\textit{e.g.}}
%~~~~~~~~~~~~~~~
% Environment shortcuts
%~~~~~~~~~~~~~~~
\newcommand{\balign}[1]{\ealign{\begin{align}#1\end{align}}}
\newcommand{\baligns}[1]{\ealigns{\begin{align*}#1\end{align*}}}
\newcommand{\bitemize}[1]{\eitemize{\begin{itemize}#1\end{itemize}}}
\newcommand{\benumerate}[1]{\eenumerate{\begin{enumerate}#1\end{enumerate}}}
%~~~~~~~~~~~~~~~
% Text with quads around it
%~~~~~~~~~~~~~~~
\newcommand{\qtext}[1]{\quad\text{#1}\quad}
%~~~~~~~~~~~~~~~
% Shorthand for math formatting
%~~~~~~~~~~~~~~~
\newcommand{\mbb}[1]{\mathbb{#1}}
\newcommand{\mbi}[1]{\boldsymbol{#1}} % Bold and italic (math bold italic)
\newcommand{\mbf}[1]{\mathbf{#1}}
\newcommand{\mc}[1]{\mathcal{#1}}
\newcommand{\mrm}[1]{\mathrm{#1}}
\newcommand{\tbf}[1]{\textbf{#1}}
\newcommand{\tsc}[1]{\textsc{#1}}
%\def\\langle {{\langle }}
%\def\\rangle {{\rangle }}
\newcommand{\sT}{\sf T}
\newcommand{\grad}{\nabla}
\newcommand{\Proj}{\Pi}
%~~~~~~~~~~~~~~~
% Common sets 定义数集符号
%~~~~~~~~~~~~~~~
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\reals}{\mathbb{R}} % Real number symbol
\newcommand{\integers}{\mathbb{Z}} % Integer symbol
\newcommand{\rationals}{\mathbb{Q}} % Rational numbers
\newcommand{\naturals}{\mathbb{N}} % Natural numbers
\newcommand{\complex}{\mathbb{C}} % Complex numbers
%~~~~~~~~~~~~~~~
% Common functions
%~~~~~~~~~~~~~~~
\renewcommand{\exp}[1]{\operatorname{exp}\left(#1\right)} % Exponential
\newcommand{\indic}[1]{\mbb{I}\left(#1\right)} % Indicator function
\newcommand{\indicsub}[2]{\mbb{I}_{#2}\left(#1\right)} % Indicator function
\newcommand{\argmax}{\mathop\mathrm{arg\, max}} % Defining math symbols
\newcommand{\argmin}{\mathop\mathrm{arg\, min}}
\renewcommand{\arccos}{\mathop\mathrm{arccos}}
\newcommand{\dom}{\mathop\mathrm{dom}} % Domain
\newcommand{\range}{\mathop\mathrm{range}} % Range
\newcommand{\diag}{\mathop\mathrm{diag}}
\newcommand{\tr}{\mathop\mathrm{tr}}
\newcommand{\abs}{\mathop\mathrm{abs}}
\newcommand{\card}{\mathop\mathrm{card}}
\newcommand{\sign}{\mathop\mathrm{sign}}
\newcommand{\prox}{\mathrm{prox}} % prox
\newcommand{\rank}[1]{\mathrm{rank}(#1)}
\newcommand{\supp}[1]{\mathrm{supp}(#1)}
\newcommand{\norm}[1]{\lVert#1\rVert}
%~~~~~~~~~~~~~~~
% Common probability symbols
%~~~~~~~~~~~~~~~
\newcommand{\family}{\mathcal{P}} % probability family / statistical model
\newcommand{\iid}{\stackrel{\mathrm{iid}}{\sim}}
\newcommand{\ind}{\stackrel{\mathrm{ind}}{\sim}}
\newcommand{\E}{\mathbb{E}} % Expectation symbol
\newcommand{\Earg}[1]{\E\left[#1\right]}
\newcommand{\Esubarg}[2]{\E_{#1}\left[#2\right]}
\renewcommand{\P}{\mathbb{P}} % Probability symbol
\newcommand{\Parg}[1]{\P\left(#1\right)}
\newcommand{\Psubarg}[2]{\P_{#1}\left[#2\right]}
%\newcommand{\Cov}{\mrm{Cov}} % Covariance symbol
%\newcommand{\Covarg}[1]{\Cov\left[#1\right]}
%\newcommand{\Covsubarg}[2]{\Cov_{#1}\left[#2\right]}
%\newcommand{\model}{\mathcal{P}} % probability family / statistical model
%~~~~~~~~~~~~~~~
% Distributions
%~~~~~~~~~~~~~~~
%\newcommand{\Gsn}{\mathcal{N}}
%\newcommand{\Ber}{\textnormal{Ber}}
%\newcommand{\Bin}{\textnormal{Bin}}
%\newcommand{\Unif}{\textnormal{Unif}}
%\newcommand{\Mult}{\textnormal{Mult}}
%\newcommand{\NegMult}{\textnormal{NegMult}}
%\newcommand{\Dir}{\textnormal{Dir}}
%\newcommand{\Bet}{\textnormal{Beta}}
%\newcommand{\Gam}{\textnormal{Gamma}}
%\newcommand{\Poi}{\textnormal{Poi}}
%\newcommand{\HypGeo}{\textnormal{HypGeo}}
%\newcommand{\GEM}{\textnormal{GEM}}
%\newcommand{\BP}{\textnormal{BP}}
%\newcommand{\DP}{\textnormal{DP}}
%\newcommand{\BeP}{\textnormal{BeP}}
%\newcommand{\Exp}{\textnormal{Exp}}
%~~~~~~~~~~~~~~~
% Theorem-like environments
%~~~~~~~~~~~~~~~
%\theoremstyle{definition}
%\newtheorem{definition}{Definition}
%\newtheorem{example}{Example}
%\newtheorem{problem}{Problem}
%\newtheorem{lemma}{Lemma}
%~~~~~~~~~~~~~~~
% 组合数学的模板和作业里用到的一些宏包和自定义命令
%~~~~~~~~~~~~~~~
\renewcommand{\emph}[1]{\begin{kaishu}#1\end{kaishu}}
\newcommand{\falfac}[1]{^{\underline{#1}}}
\newcommand{\binomfrac}[2]{\frac{#1^{\underline{#2}}}{#2!}}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\suminfty}[2]{\sum_{#1=#2}^{\infty}}
\newcommand{\suminftyk}[0]{\sum_{k=0}^{\infty}}
\newcommand{\sumint}[3]{\sum_{#1=#2}^{#3}}
\newcommand{\sumintk}[2]{\sum_{k=#1}^{#2}}
\newcommand{\suminti}[2]{\sum_{i=#1}^{#2}}
%~~~~~~~~~~~~~~~
% 定义新命令
%~~~~~~~~~~~~~~~
\newcommand*{\unit}[1]{\mathop{}\!\mathrm{#1}}
\newcommand*{\dif}{\mathop{}\!\mathrm{d}}%微分算子 d
\newcommand*{\pdif}{\mathop{}\!\partial}%偏微分算子
\newcommand*{\cdif}{\mathop{}\!\nabla}%协变导数、nabla 算子
\newcommand*{\laplace}{\mathop{}\!\Delta}%laplace 算子
\newcommand*{\deri}[1]{\mathrm{d} #1}
\newcommand*{\deriv}[2]{\frac{\mathrm{d} #1}{\mathrm{d} {#2}}}
\newcommand*{\derivh}[3]{\frac{\mathrm{d}^{#1} #2}{\mathrm{d} {#3^{#1}}}}
\newcommand*{\pderiv}[2]{\frac{\partial #1}{\partial {#2}}}
\newcommand*{\pderivh}[3]{\frac{\partial^{#1} #2}{\partial {#3^{#1}}}}
\newcommand*{\dderiv}[2]{\dfrac{\mathrm{d} #1}{\mathrm{d} {#2}}}
\newcommand*{\dderivh}[3]{\dfrac{\mathrm{d}^{#1} #2}{\mathrm{d} {#3^{#1}}}}
\newcommand*{\dpderiv}[2]{\dfrac{\partial #1}{\partial {#2}}}
\newcommand*{\dpderivh}[3]{\dfrac{\partial^{#1} #2}{\partial {#3^{#1}}}}
\newcommand{\me}[1]{\mathrm{e}^{#1}}%e 指数
\newcommand{\mi}{\mathrm{i}}%虚数单位
%\newcommand{\mc}{\mathrm{c}}%光速 定义与mathcal冲突
\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcommand{\blue}[1]{\textcolor{blue}{#1}}
%\newcommand{\Rome}[1]{\setcounter{rome}{#1}\Roman{rome}}
%~~~~~~~~~~~~~~~
% 公式环境中箭头符号的简写
%~~~~~~~~~~~~~~~
\newcommand{\ra}{\rightarrow}
\newcommand{\Ra}{\Rightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\La}{\Leftarrow}
\newcommand{\lra}{\leftrightarrow}
\newcommand{\Lra}{\Leftrightarrow}
\newcommand{\lgla}{\longleftarrow}
\newcommand{\Lgla}{\Longleftarrow}
\newcommand{\lgra}{\longrightarrow}
\newcommand{\Lgra}{\Longrightarrow}
\newcommand{\lglra}{\longleftrightarrow}
\newcommand{\Lglra}{\Longleftrightarrow}
%~~~~~~~~~~~~~~~
% 一些数学的环境设置
%~~~~~~~~~~~~~~~
%\newcounter{counter_exm}\setcounter{counter_exm}{1}
%\newcounter{counter_prb}\setcounter{counter_prb}{1}
%\newcounter{counter_thm}\setcounter{counter_thm}{1}
%\newcounter{counter_lma}\setcounter{counter_lma}{1}
%\newcounter{counter_dft}\setcounter{counter_dft}{1}
%\newcounter{counter_clm}\setcounter{counter_clm}{1}
%\newcounter{counter_cly}\setcounter{counter_cly}{1}
\newtheorem{theorem}{{\hskip 1.7em \bf 定理}}
\newtheorem{lemma}[theorem]{\hskip 1.7em 引理}
\newtheorem{proposition}[theorem]{\hskip 1.7em 命题}
\newtheorem{claim}[theorem]{\hskip 1.7em 断言}
\newtheorem{corollary}[theorem]{\hskip 1.7em 推论}
% \newcommand{\problem}[1]{{\setlength{\parskip}{10pt}\noindent \bf{#1}}}
\newenvironment{solution}{{\noindent \bf 解 \quad}}{}
\newenvironment{remark}{{\noindent \bf 注 \quad}}{}
\newenvironment{definition}{{\noindent \bf 定义 \quad}}{}
\renewenvironment{proof}{{\setlength{\parskip}{7pt}\noindent\hskip 2em \bf 证明 \quad}}{\hfill$\qed$\par}
\newenvironment{example}{{\noindent\bf 例 \quad}}{\hfill$\qed$\par}
%\newenvironment{concept}[1]{{\bf #1\quad} \begin{kaishu}} {\end{kaishu}\par}
%~~~~~~~~~~~~~~~
% 本.tex文档中特殊定义命令
%~~~~~~~~~~~~~~~
\newcommand{\lno}[1]{\overline{#1}}
\newcommand{\NP}{\mathrm{NP}}
\newcommand{\coNP}{\mathrm{coNP}}
% \newcommand{\ISO}{\mathrm{ISO}}
\newcommand{\SAT}{\mathrm{SAT}}
\newcommand{\USAT}{\mathrm{USAT}}
% \newcommand{\threeSAT}{\mathrm{3\text{-}SAT}}
\renewcommand{\P}{\mathrm{P}}
% \mathchardef\mhyphen="2D
% \newcommand{\CNF}{\mathrm{CNF}}
% \newcommand{\DNF}{\mathrm{DNF}}
% \newcommand{\SetSp}{\mathrm{SET\text{-}SPLITTING}}
% \newcommand{\PUZZLE}{\mathrm{PUZZLE}}
% \newcommand{\SPATH}{\mathrm{SPATH}}
% \newcommand{\LPATH}{\mathrm{LPATH}}
% \newcommand{\UHAMPATH}{\mathrm{UHAMPATH}}
\newcommand{\SPACE}{\mathrm{SPACE}}
\newcommand{\NSPACE}{\mathrm{NSPACE}}
\newcommand{\PSPACE}{\mathrm{PSPACE}}
\newcommand{\NPSPACE}{\mathrm{NPSPACE}}
\newcommand{\DFA}{\mathrm{DFA}}
\newcommand{\NFA}{\mathrm{NFA}}
\newcommand{\TQBF}{\mathrm{TQBF}}
% \newcommand{\L}{\mathrm{L}}
\renewcommand{\O}{\mathrm{O}}
\newcommand{\NL}{\mathrm{NL}}
\newcommand{\coNL}{\mathrm{coNL}}
\newcommand{\LADDER}{\mathrm{LADDER_{DFA}}}
\newcommand{\hd}{\mathrm{\text{-}hard}}
\newcommand{\ADD}{\mathrm{ADD}}
\newcommand{\STCN}{\mathrm{STRONGLY\text{-}CONNECTED}}
\newcommand{\PATH}{\mathrm{PATH}}
\newcommand{\A}{\mathrm{A}}
%使用align环境公式换页
\allowdisplaybreaks[4]

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{
  frame=tb,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  framerule=1pt,
  rulecolor=\color{gray!35},
  backgroundcolor=\color{gray!5},
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}

\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=red!30]
\tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=orange!30]
\tikzstyle{decision} = [diamond, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=green!30]
\tikzstyle{arrow} = [thick,->,>=stealth]

\setmainfont{Times New Roman}
\setsansfont{Times New Roman}
\setmonofont{Consolas}
\setCJKmainfont{SimHei}
\setCJKsansfont{SimSun}
\setCJKmonofont{FangSong}
\punctstyle{kaiming}

\begin{document}

\pagestyle{fancy}

\reporttype{Report}                 % required
\course{Lab of Computer Network} 				% optional
\coursetitle{Hub \& Switch}	    % optional
\semester{Fall 2024}			    % optional
\lecturer{Wu Qinghua}			% optional
\scribe{Zhang Jiawei}			% required
\lecturenumber{4}				% required (must be a number)
\lecturedate{September 26}			% required (omit year)
\maketitle

\begin{center}
    \Large \bf 第一部分 \quad Hub
\end{center}

\section{实验内容}

\begin{enumerate}
    \item 实现节点广播的broadcast_packet函数
    \item 验证广播网络能够正常运行（从一个端节点ping另一个端节点）
    \item 验证广播网络的效率（分两种场景在three_nodes_bw.py进行iperf测量，h1同时向h2和h3测量与h2和h3 同时向h1测量）
    \item 自己动手构建环形拓扑，验证该拓扑下节点广播会产生数据包环路
\end{enumerate}

\section{实验过程}

\subsection{实现节点广播的broadcast\_packet函数}

\begin{lstlisting}[language=C]
    // the memory of ``packet'' will be free'd in handle_packet().
    void broadcast_packet(iface_info_t *iface, const char *packet, int len)
    {
        // TODO: broadcast packet 
        // fprintf(stdout, "TODO: broadcast packet.\n");
        iface_info_t *iface_entry;
        list_for_each_entry(iface_entry, &instance->iface_list, list) {
            if (iface_entry->fd != iface->fd) 
                iface_send_packet(iface_entry, packet, len);
        }
    }
\end{lstlisting}

在这个函数里，我们遍历所有的接口，如果遍历到的接口不是发送所收到网络包的接口，就调用\texttt{iface\_send\_packet}函数广播发送数据包。

\subsection{验证广播网络能够正常运行}

拓扑图如下：

\begin{figure}[H]
    \centering
    \includegraphics[width=0.35\textwidth]{topo1.png}
    \caption{广播网络拓扑图}
\end{figure}

h1, h2, h3分别是三个节点，它们如果能够相互ping通，说明广播网络能够正常运行。这里h1的IP地址是10.0.0.1，h2的IP地址是10.0.0.2，h3的IP地址是10.0.0.3。

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{h1ping.png}
    \caption{h1 ping h2, h3}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{h2ping.png}
    \caption{h2 ping h1, h3}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{h3ping.png}
    \caption{h3 ping h1, h2}
\end{figure}

可以看出，h1, h2, h3三个节点确实能够相互ping通，这表明广播网络能够正常运行。

\subsection{验证广播网络的效率}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{h1toh2.png}
    \caption{h1向h2测量}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{h1toh3.png}
    \caption{h1向h3测量}
\end{figure}

可以看出，h1向h2测量和h1向h3测量的实际速率差异较大，而且都远未达到理论带宽值。这是因为h1发出的数据都会广播至h2和h3，实际来看，h1发送给h2的数据会占据b1到h3的带宽，而h1发送给h3的数据也会占据b1到h2的带宽，所以实际速率必定达不到理论带宽值。而对于实际速率的差异，我的解释是，因为我们在xterm终端中并不能保证两个iperf进程同时启动，所以会造成TCP窗口大小的差异，从而导致实际速率的差异。可以预测出的是，在接下来的h2向h1测量和h3向h1测量中，因为路径不是竞争关系，所以速率应该会更接近理论带宽值。事实果然如此：

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{h2toh1.png}
    \caption{h2向h1测量}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{h3toh1.png}
    \caption{h3向h1测量}
\end{figure}

\subsection{构建环形拓扑，验证数据包环路}

拓扑图如下：

\begin{figure}[H]
    \centering
    \includegraphics[width=0.35\textwidth]{topo2.png}
    \caption{环形拓扑图}
\end{figure}

此时需要更改\texttt{three\_nodes\_bw.py}文件，重新配置拓扑：

\begin{lstlisting}[language=Python]
    class BroadcastTopo(Topo):
    def build(self):
        h1 = self.addHost('h1')
        h2 = self.addHost('h2')
        b1 = self.addHost('b1')
        b2 = self.addHost('b2')
        b3 = self.addHost('b3')

        self.addLink(h1, b1, bw=10)
        self.addLink(h2, b2, bw=10)
        self.addLink(b1, b2, bw=10)
        self.addLink(b2, b3, bw=10)
        self.addLink(b3, b1, bw=10)
\end{lstlisting}

使用h1向h2广播ping消息，经wireshark抓包，可以看到数据包在环路中不断传递：

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{ring.png}
    \caption{数据包环路}
\end{figure}

可以看到，h1一直收到来自h2的相同消息，这说明数据包在环路中不断被广播，根本在于拓扑网络出现了环路，使得数据包不断被循环转发。

\section{实验总结}

本次实验主要是关于广播网络的实验，我实现了节点广播的函数，验证了广播网络的正常运行和效率，以及验证了环形拓扑下数据包环路的现象。实验过程中，我对广播网络的工作原理有了更深入的了解，广播网络会占据更多的网络资源，效率低下。我也对环形拓扑下数据包环路的现象有了直观的认识，这是广播网络的一个关键弱点，一旦出现环路，数据包会不断被循环转发，直到网络崩溃。于是，为了避免这种情况以及提高效率，新的转发机制亟待设计，这就是马上就要进行实验的交换机网络。

\newpage
\setcounter{section}{0}
\begin{center}
    \Large \bf 第二部分 \quad Switch
\end{center}

\section{实验内容}

\begin{enumerate}
    \item 实现对数据结构\texttt{mac_port_map}的所有操作，以及数据包的转发和广播操作
    
    \begin{lstlisting}[language=C]
        iface_info_t *lookup_port(u8 mac[ETH_ALEN]);
        void insert_mac_port(u8 mac[ETH_ALEN], iface_info_t *iface);
        int sweep_aged_mac_port_entry();
        void broadcast_packet(iface_info_t *iface, const char *packet, int len);
        void handle_packet(iface_info_t *iface, char *packet, int len);
    \end{lstlisting}

    \item 使用iperf和给定的拓扑进行实验，对比交换机转发与集线器广播的性能
\end{enumerate}

\section{实验过程}

\subsection{实现转发表的查询操作}

\begin{lstlisting}[language=C]
    // lookup the mac address in mac_port table
    iface_info_t *lookup_port(u8 mac[ETH_ALEN])
    {
        // TODO: implement the lookup process here
        // fprintf(stdout, "TODO: implement the lookup process here.\n");
        int hash = (int)hash8((char *)mac, ETH_ALEN);
        mac_port_entry_t *entry;
        pthread_mutex_lock(&mac_port_map.lock);
    
        list_for_each_entry(entry, &mac_port_map.hash_table[hash], list) {
            if (memcmp(entry->mac, mac, ETH_ALEN) == 0) {
                pthread_mutex_unlock(&mac_port_map.lock);
                return entry->iface;
            }
        }
    
        pthread_mutex_unlock(&mac_port_map.lock);
        return NULL;
    }
\end{lstlisting}

在这个函数里，我们首先计算出mac地址的哈希值，然后遍历哈希表，如果找到了对应的mac地址，就返回对应的接口信息，否则返回\texttt{NULL}。函数中需要线程互斥锁是因为多个线程可能同时访问转发表（比如之后的老化操作）。

\subsection{实现转发表的插入操作}

\begin{lstlisting}[language=C]
    // insert the mac -> iface mapping into mac_port table
    void insert_mac_port(u8 mac[ETH_ALEN], iface_info_t *iface)
    {
        // TODO: implement the insertion process here
        // fprintf(stdout, "TODO: implement the insertion process here.\n");
        int hash = (int)hash8((char *)mac, ETH_ALEN);
        mac_port_entry_t *entry;
        pthread_mutex_lock(&mac_port_map.lock);
    
        list_for_each_entry(entry, &mac_port_map.hash_table[hash], list) {
            if (memcmp(entry->mac, mac, ETH_ALEN) == 0) {
                entry->iface = iface;
                entry->visited = time(NULL);
                pthread_mutex_unlock(&mac_port_map.lock);
                return;
            }
        }
    
        mac_port_entry_t *nentry = (mac_port_entry_t *)malloc(sizeof(mac_port_entry_t));
        nentry->iface = iface;
        nentry->visited = time(NULL);
        for (int i = 0; i < ETH_ALEN; i++)
            nentry->mac[i] = mac[i];
        list_add_head(&nentry->list, &mac_port_map.hash_table[hash]);
    
        pthread_mutex_unlock(&mac_port_map.lock);
        return;
    }
\end{lstlisting}

仍然计算出mac地址的哈希值，然后遍历哈希表，如果找到了对应的mac地址，就更新对应的接口信息，否则新建一个新的表项插入到哈希表中。这里需要注意的是，每次插入新的表项时，需要更新访问时间。同理，函数中需要线程互斥锁，因为多个线程可能同时访问转发表（比如之后的老化操作）。

\subsection{实现转发表的老化操作}

\begin{lstlisting}[language=C]
    // sweeping mac_port table, remove the entry which has not been visited in the
    // last 30 seconds.
    int sweep_aged_mac_port_entry()
    {
        // TODO: implement the sweeping process here
        // fprintf(stdout, "TODO: implement the sweeping process here.\n");
        mac_port_entry_t *entry, *q;
        int n = 0;
        time_t now = time(NULL);
        pthread_mutex_lock(&mac_port_map.lock);
        
        for (int i = 0; i < HASH_8BITS; i++) {
            list_for_each_entry_safe(entry, q, &mac_port_map.hash_table[i], list) {
                if ((int)(now - entry->visited) > MAC_PORT_TIMEOUT) {
                    list_delete_entry(&entry->list);
                    free(entry);
                    n++;
                }
            }
        }
    
        pthread_mutex_unlock(&mac_port_map.lock);
        return n;
    }
\end{lstlisting}

老化操作是删除那些访问时间超过30秒的表项，即扫描转发表，清理那些当前时间与上次访问时间之差大于30秒的表项。这里需要注意的是，老化操作是线程安全的，因为在老化操作时，可能有其他线程在访问转发表（比如插入操作）。

\subsection{实现数据包的广播操作}

代码与实验一中的相同，这里不再赘述。

\subsection{实现数据包的处理}

\begin{lstlisting}[language=C]
    // handle packet
    // 1. if the dest mac address is found in mac_port table, forward it; otherwise, 
    // broadcast it.
    // 2. put the src mac -> iface mapping into mac hash table.
    // 3. release the memory of ``packet''
    
    // Note: the log & fprintf here are only used for debug, which should be commented 
    // out for better performance.
    void handle_packet(iface_info_t *iface, char *packet, int len)
    {
        // TODO: implement the packet forwarding process here
        // fprintf(stdout, "TODO: implement the packet forwarding process here.\n");
    
        struct ether_header *eh = (struct ether_header *)packet;
        // log(DEBUG, "the dst mac address is " ETHER_STRING ".\n", ETHER_FMT(eh->ether_dhost));
    
        iface_info_t *dst_iface = lookup_port(eh->ether_dhost);
        if (dst_iface) 
            iface_send_packet(dst_iface, packet, len);
        else 
            broadcast_packet(iface, packet, len);
    
        insert_mac_port(eh->ether_shost, iface);
    
        free(packet);
    }
\end{lstlisting}

在这个函数里，我们首先解析数据包，然后查找目的mac地址对应的接口信息，如果找到了，就转发数据包，否则广播发送数据包。接着将源mac地址和接口信息插入到转发表中，最后释放数据包的内存。

\subsection{测量交换机转发的性能与集线器广播的性能对比}

拓扑图如下：

\begin{figure}[H]
    \centering
    \includegraphics[width=0.35\textwidth]{topo1.png}
    \caption{交换机网络拓扑图}
\end{figure}

与实验一中的拓扑相同，这里直接开始测量交换机转发的性能。

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{h1toh2_2.png}
    \caption{h1向h2测量}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{h1toh3_2.png}
    \caption{h1向h3测量}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{h2toh1_2.png}
    \caption{h2向h1测量}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{h3toh1_2.png}
    \caption{h3向h1测量}
\end{figure}

在h1向h2测量和h1向h3测量中，实验结果与实验一差距较大，速率已经接近理论带宽值。这是因为交换机网络中，数据包除了第一次转发表为空之外不会被广播，而是根据目的mac地址直接转发，所以不会出现竞争关系，速率更接近理论带宽值，带宽得到了充分利用。

h2向h1测量和h3向h1测量的结果也与预期一致，速率接近理论带宽值，这是因为路径不是竞争关系，所以速率应该会更接近理论带宽值。这个原因与实验一中的解释相同。

总体而言，交换机网络的性能要好于集线器广播网络，尤其是当广播网络因各种各样原因导致数据包竞争时，交换机网络的性能优势更加明显。即便首次传播时需要进行广播，但是交换机网络会学习到目的mac地址，之后的数据包都会直接转发，不会再广播，这样就避免了数据包竞争，提高了网络性能。

\section{实验总结}

本次实验主要是关于交换机网络的实验，我实现了转发表的查询、插入和老化操作，以及数据包的转发和广播操作，验证了交换机网络的性能优势。实验过程中，我对交换机网络的工作原理有了更深入的了解，交换机网络会学习到目的mac地址，之后的数据包都会直接转发，不会再广播，这样就避免了数据包竞争，提高了网络性能。而集线器广播网络则会占据更多的网络资源，效率低下。这也是交换机网络取代集线器网络的原因之一。
\end{document}